#!/usr/bin/env node
const { execSync } = require('child_process');
const { writeFileSync, mkdirSync, readFileSync, existsSync } = require('fs');
const { join } = require('path');

function getHash() {
  try { return execSync('git rev-parse --short HEAD').toString().trim(); } catch { return 'dev'; }
}

function readSemanticBase() {
  const file = join(process.cwd(), 'version.semver');
  if (!existsSync(file)) return '1.0.0';
  return readFileSync(file, 'utf8').trim();
}

const commitHash = getHash();
let semantic = readSemanticBase(); // major.minor.patch

// If previous version.json exists, only increment patch when commit changed
const outDir = join(process.cwd(), 'public');
try { mkdirSync(outDir, { recursive: true }); } catch {}
const versionFile = join(outDir, 'version.json');
let previous = null;
if (existsSync(versionFile)) {
  try { previous = JSON.parse(readFileSync(versionFile, 'utf8')); } catch {}
}

if (previous && previous.commitHash !== commitHash) {
  // Only auto-increment if user did NOT manually bump (i.e. file value == previous semanticVersion)
  if (previous.semanticVersion === semantic) {
    const parts = semantic.split('.');
    if (parts.length === 3) {
      const patch = parseInt(parts[2], 10) || 0;
      parts[2] = String(patch + 1);
      semantic = parts.join('.');
      writeFileSync(join(process.cwd(), 'version.semver'), semantic + '\n');
    }
  } else {
    // Respect manual bump; do not increment
  }
}

const builtAt = new Date().toISOString();
writeFileSync(versionFile, JSON.stringify({ semanticVersion: semantic, commitHash, builtAt }, null, 2));
// Also create JS module for direct import (avoids relying on define fallback "dev")
const versionJsPath = join(process.cwd(), 'src', 'version-app.js');
writeFileSync(versionJsPath, `// auto-generated by gen-version.cjs\nexport const APP_VERSION = '${semantic}';\n`);
console.log(`[gen-version] version.json + version-app.js created semantic=${semantic} commit=${commitHash}`);
